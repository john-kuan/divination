<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Seed Protocol Prompt Builder</title>
    <style>
      :root {
        color-scheme: dark;
        --bg: #0b0f14;
        --panel: #0f1620;
        --panel-2: #0c121a;
        --text: #e6edf3;
        --muted: #9fb0c0;
        --border: #233041;
        --accent: #86b7ff;
        --good: #7ee787;
        --warn: #f2cc60;
        --bad: #ff7b72;
        --shadow: rgba(0, 0, 0, 0.35);
      }

      * { box-sizing: border-box; }

      body {
        margin: 0;
        font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji";
        background: radial-gradient(1200px 700px at 20% -10%, rgba(134, 183, 255, 0.10), transparent 55%),
          radial-gradient(900px 550px at 90% 0%, rgba(126, 231, 135, 0.08), transparent 50%),
          var(--bg);
        color: var(--text);
      }

      .wrap {
        max-width: 980px;
        margin: 0 auto;
        padding: 28px 16px 40px;
      }

      header {
        display: flex;
        align-items: flex-start;
        justify-content: space-between;
        gap: 16px;
        margin-bottom: 18px;
      }

      h1 {
        margin: 0;
        font-size: 22px;
        letter-spacing: 0.2px;
      }

      .sub {
        margin-top: 6px;
        color: var(--muted);
        font-size: 13px;
        line-height: 1.35;
      }

      .grid {
        display: grid;
        grid-template-columns: 1fr;
        gap: 14px;
      }

      @media (min-width: 920px) {
        .grid { grid-template-columns: 1.05fr 0.95fr; }
      }

      .card {
        background: linear-gradient(180deg, rgba(255, 255, 255, 0.02), transparent 55%), var(--panel);
        border: 1px solid var(--border);
        border-radius: 16px;
        box-shadow: 0 18px 40px var(--shadow);
        padding: 16px;
      }

      .card h2 {
        margin: 0 0 10px;
        font-size: 14px;
        letter-spacing: 0.25px;
        color: var(--muted);
        text-transform: uppercase;
      }

      label {
        display: block;
        font-size: 12px;
        color: var(--muted);
        margin: 12px 0 6px;
      }

      input[type="text"], textarea, select, input[type="datetime-local"], input[type="date"] {
        width: 100%;
        background: var(--panel-2);
        color: var(--text);
        border: 1px solid var(--border);
        border-radius: 12px;
        padding: 10px 12px;
        font-size: 14px;
        outline: none;
      }

      input[type="text"]:focus, textarea:focus, select:focus, input[type="datetime-local"]:focus, input[type="date"]:focus {
        border-color: rgba(134, 183, 255, 0.75);
        box-shadow: 0 0 0 3px rgba(134, 183, 255, 0.15);
      }

      textarea {
        min-height: 220px;
        resize: vertical;
        line-height: 1.35;
        white-space: pre;
      }

      .row {
        display: grid;
        grid-template-columns: 1fr;
        gap: 10px;
      }

      @media (min-width: 520px) {
        .row { grid-template-columns: 1fr 1fr; }
      }

      .btns {
        display: flex;
        flex-wrap: wrap;
        gap: 10px;
        margin-top: 14px;
      }

      button {
        appearance: none;
        border: 1px solid var(--border);
        background: rgba(134, 183, 255, 0.10);
        color: var(--text);
        padding: 10px 12px;
        border-radius: 12px;
        font-weight: 600;
        font-size: 13px;
        cursor: pointer;
        transition: transform 0.06s ease, background 0.15s ease, border-color 0.15s ease;
      }

      button:hover {
        background: rgba(134, 183, 255, 0.16);
        border-color: rgba(134, 183, 255, 0.45);
      }

      button:active { transform: translateY(1px); }

      button.secondary {
        background: rgba(255, 255, 255, 0.04);
      }

      button.danger {
        background: rgba(255, 123, 114, 0.08);
      }

      .pill {
        display: inline-flex;
        align-items: center;
        gap: 8px;
        padding: 8px 10px;
        border: 1px solid var(--border);
        border-radius: 999px;
        background: rgba(255, 255, 255, 0.03);
        font-size: 12px;
        color: var(--muted);
        margin-top: 10px;
      }

      .dot {
        width: 8px;
        height: 8px;
        border-radius: 999px;
        background: var(--warn);
      }

      .dot.good { background: var(--good); }
      .dot.bad { background: var(--bad); }

      .mono {
        font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      }

      .small {
        font-size: 12px;
        color: var(--muted);
        line-height: 1.35;
      }

      .hr {
        height: 1px;
        background: var(--border);
        margin: 14px 0;
      }

      .kv {
        display: grid;
        grid-template-columns: 140px 1fr;
        gap: 8px 12px;
        font-size: 13px;
        align-items: baseline;
      }

      .kv div:nth-child(odd) { color: var(--muted); }
      .kv div:nth-child(even) { color: var(--text); }

      .list {
        margin: 10px 0 0;
        padding-left: 18px;
        color: var(--text);
        font-size: 13px;
        line-height: 1.45;
      }

      .warnbox {
        border: 1px solid rgba(242, 204, 96, 0.35);
        background: rgba(242, 204, 96, 0.06);
        border-radius: 12px;
        padding: 10px 12px;
        margin-top: 12px;
        color: var(--muted);
        font-size: 12px;
        line-height: 1.35;
      }

      .nowrap { white-space: nowrap; }
    </style>
  </head>

  <body>
    <div class="wrap">
      <header>
        <div>
          <h1>Workflow B Prompt Builder</h1>
          <div class="sub">
            Single-file HTML for GitHub Pages, with accurate Dreamspell (Argüelles) and Vedic (sidereal Lahiri) calculations.
          </div>
        </div>
        <div class="pill" id="statusPill" title="Library status">
          <span class="dot" id="statusDot"></span>
          <span id="statusText">Loading Swiss Ephemeris…</span>
        </div>
      </header>

      <div class="grid">
        <section class="card">
          <h2>Inputs</h2>

          <div class="row">
            <div>
              <label for="seed">Seed (max 64 chars)</label>
              <input id="seed" type="text" class="mono" maxlength="64" placeholder="(leave blank or generate noise)" />
              <div class="small" id="seedCount">0 / 64</div>

              <div class="btns">
                <button id="genSeedBtn" type="button">Generate Noise Seed</button>
                <button id="clearBtn" type="button" class="danger">Clear</button>
              </div>
            </div>

            <div>
              <label for="when">Date and Time (America/Detroit)</label>
              <input id="when" type="datetime-local" />
              <div class="small">
                Used for Vedic transits (converted to UTC internally). Dreamspell uses the calendar date portion.
              </div>

              <label for="streams" style="margin-top: 12px;">Streams</label>
              <select id="streams">
                <option value="A-iching_B-tarot" selected>Stream A = I Ching, Stream B = Tarot</option>
                <option value="A-tarot_B-iching">Stream A = Tarot, Stream B = I Ching</option>
              </select>
              <div class="small">
                This only formats the prompt; it does not force linking numbers between systems.
              </div>
            </div>
          </div>

          <div class="hr"></div>

          <div class="btns">
            <button id="buildBtn" type="button">Build Prompt</button>
            <button id="copyBtn" type="button" class="secondary">Copy Prompt</button>
          </div>

          <div class="warnbox">
            Note: Swiss Ephemeris WASM is GPL-licensed; keep your repo open-source if you publish this on GitHub Pages.
          </div>
        </section>

        <section class="card">
          <h2>Output</h2>
          <label for="prompt">Prompt</label>
          <textarea id="prompt" class="mono" readonly></textarea>
          <div class="small" id="copyState"></div>

          <div class="hr"></div>

          <h2>Calculated Components</h2>

          <div class="kv">
            <div>Dreamspell</div>
            <div id="dreamspellLine" class="mono">—</div>

            <div>13 Moon Date</div>
            <div id="moonLine" class="mono">—</div>

            <div>Vedic Sidereal</div>
            <div id="vedicLine" class="mono">—</div>
          </div>

          <ul class="list" id="vedicList"></ul>
        </section>
      </div>
    </div>

    <script type="module">
      // Swiss Ephemeris WASM wrapper (GPL). CDN import pattern per project README.
      // Source: https://github.com/prolaxu/swisseph-wasm
      import SwissEph from "https://cdn.jsdelivr.net/gh/prolaxu/swisseph-wasm@main/src/swisseph.js";

      const seedEl = document.getElementById("seed");
      const seedCountEl = document.getElementById("seedCount");
      const genSeedBtn = document.getElementById("genSeedBtn");
      const clearBtn = document.getElementById("clearBtn");
      const whenEl = document.getElementById("when");
      const streamsEl = document.getElementById("streams");
      const buildBtn = document.getElementById("buildBtn");
      const copyBtn = document.getElementById("copyBtn");
      const promptEl = document.getElementById("prompt");
      const copyStateEl = document.getElementById("copyState");

      const statusDot = document.getElementById("statusDot");
      const statusText = document.getElementById("statusText");
      const dreamspellLine = document.getElementById("dreamspellLine");
      const moonLine = document.getElementById("moonLine");
      const vedicLine = document.getElementById("vedicLine");
      const vedicList = document.getElementById("vedicList");

      // ----- Seed UI -----
      function updateSeedCount() {
        seedCountEl.textContent = `${seedEl.value.length} / 64`;
      }
      seedEl.addEventListener("input", updateSeedCount);
      updateSeedCount();

      function cryptoNoise64() {
        // 64 chars from URL-safe base64 (no padding)
        const bytes = new Uint8Array(48); // 48 bytes -> 64 base64 chars
        crypto.getRandomValues(bytes);
        let bin = "";
        for (const b of bytes) bin += String.fromCharCode(b);
        const b64 = btoa(bin).replaceAll("+", "-").replaceAll("/", "_").replaceAll("=", "");
        return b64.slice(0, 64);
      }

      genSeedBtn.addEventListener("click", () => {
        seedEl.value = cryptoNoise64();
        updateSeedCount();
        refreshAll();
      });

      clearBtn.addEventListener("click", () => {
        seedEl.value = "";
        updateSeedCount();
        promptEl.value = "";
        copyStateEl.textContent = "";
        refreshAll();
      });

      // ----- Default datetime-local to "now" -----
      function pad2(n) { return String(n).padStart(2, "0"); }
      function setNowLocal() {
        const d = new Date();
        const v = `${d.getFullYear()}-${pad2(d.getMonth()+1)}-${pad2(d.getDate())}T${pad2(d.getHours())}:${pad2(d.getMinutes())}`;
        whenEl.value = v;
      }
      setNowLocal();

      // ----- Dreamspell (Argüelles) -----
      // Anchor: July 26, 1987 = Kin 34 (White Galactic Wizard)
      const DREAMSPELL_ANCHOR = { y: 1987, m: 7, d: 26, kin: 34 };

      const TONES = [
        null,
        "Magnetic","Lunar","Electric","Self-Existing","Overtone","Rhythmic","Resonant",
        "Galactic","Solar","Planetary","Spectral","Crystal","Cosmic"
      ];
      const SEALS = [
        null,
        "Red Dragon","White Wind","Blue Night","Yellow Seed","Red Serpent",
        "White Worldbridger","Blue Hand","Yellow Star","Red Moon","White Dog",
        "Blue Monkey","Yellow Human","Red Skywalker","White Wizard","Blue Eagle",
        "Yellow Warrior","Red Earth","White Mirror","Blue Storm","Yellow Sun"
      ];

      // 13 Moon calendar helpers
      const MOON_NAMES = [
        null,
        "Magnetic","Lunar","Electric","Self-Existing","Overtone","Rhythmic","Resonant",
        "Galactic","Solar","Planetary","Spectral","Crystal","Cosmic"
      ];
      const WEEKDAY_NAMES = ["Dali","Seli","Gamma","Kali","Alpha","Limi","Silio"];

      function isLeapYearGregorian(y) {
        return (y % 4 === 0 && y % 100 !== 0) || (y % 400 === 0);
      }

      function isHunabKu(y, m, d) {
        return m === 2 && d === 29;
      }

      function utcDaysBetween(y1, m1, d1, y2, m2, d2) {
        const t1 = Date.UTC(y1, m1 - 1, d1);
        const t2 = Date.UTC(y2, m2 - 1, d2);
        return Math.round((t2 - t1) / 86400000);
      }

      function countFeb29BetweenExclusive(startY, startM, startD, endY, endM, endD) {
        // Count Feb 29 dates strictly between start date and end date (inclusive of end for convenience),
        // excluding start. Works forward or backward.
        const forward = Date.UTC(endY, endM - 1, endD) >= Date.UTC(startY, startM - 1, startD);
        let aY = startY, aM = startM, aD = startD;
        let bY = endY, bM = endM, bD = endD;

        if (!forward) {
          aY = endY; aM = endM; aD = endD;
          bY = startY; bM = startM; bD = startD;
        }

        let count = 0;
        for (let y = aY; y <= bY; y++) {
          if (!isLeapYearGregorian(y)) continue;
          // Feb 29 in year y
          const t = Date.UTC(y, 1, 29);
          const tStart = Date.UTC(aY, aM - 1, aD);
          const tEnd = Date.UTC(bY, bM - 1, bD);
          if (t > tStart && t <= tEnd) count++;
        }
        return forward ? count : -count;
      }

      function dreamspellKinForDate(y, m, d) {
        if (isHunabKu(y, m, d)) {
          return { kind: "hunabku" };
        }

        const rawDiff = utcDaysBetween(DREAMSPELL_ANCHOR.y, DREAMSPELL_ANCHOR.m, DREAMSPELL_ANCHOR.d, y, m, d);

        // Dreamspell removes Feb 29 from the count (0.0 Hunab Ku, no Kin)
        const feb29Adjust = countFeb29BetweenExclusive(DREAMSPELL_ANCHOR.y, DREAMSPELL_ANCHOR.m, DREAMSPELL_ANCHOR.d, y, m, d);

        const adjustedDiff = rawDiff - feb29Adjust;

        let kin = ((DREAMSPELL_ANCHOR.kin - 1 + adjustedDiff) % 260);
        if (kin < 0) kin += 260;
        kin += 1;

        const tone = ((kin - 1) % 13) + 1;
        const seal = ((kin - 1) % 20) + 1;

        return { kind: "kin", kin, tone, seal };
      }

      function thirteenMoonDate(y, m, d) {
        // Returns 13 Moon calendar fields for the given Gregorian date.
        // Treat Feb 29 as Hunab Ku.
        if (isHunabKu(y, m, d)) {
          return { kind: "hunabku" };
        }

        // Determine 13 Moon year start (July 26) for this date.
        // If date is before July 26, it belongs to the year that started previous July 26.
        let yearStartY = y;
        const tDate = Date.UTC(y, m - 1, d);
        const tStartThis = Date.UTC(y, 6, 26); // July = 6
        if (tDate < tStartThis) yearStartY = y - 1;

        const yearStart = { y: yearStartY, m: 7, d: 26 };
        const dayIndexRaw = utcDaysBetween(yearStart.y, yearStart.m, yearStart.d, y, m, d);

        // Adjust for Hunab Ku within the year range (Feb 29)
        const hunabAdjust = countFeb29BetweenExclusive(yearStart.y, yearStart.m, yearStart.d, y, m, d);
        const dayIndex = dayIndexRaw - hunabAdjust; // 0-based day count in 365-day 13-moon system (with DOOT)

        if (dayIndex < 0) {
          return { kind: "unknown" };
        }

        // Day Out of Time is day 364 (0-based) = July 25.
        const DOOT_INDEX = 364;

        if (dayIndex === DOOT_INDEX) {
          return { kind: "doot", label: "Day Out of Time" };
        }

        if (dayIndex > DOOT_INDEX) {
          // Should not happen except weird inputs
          return { kind: "unknown" };
        }

        // 13 moons of 28 days = 364 days indexed 0..363
        const moon = Math.floor(dayIndex / 28) + 1;          // 1..13
        const dayOfMoon = (dayIndex % 28) + 1;               // 1..28
        const weekday = WEEKDAY_NAMES[dayIndex % 7];         // 0..6

        return { kind: "moon", moon, dayOfMoon, weekday, moonName: MOON_NAMES[moon] };
      }

      // ----- Vedic (Sidereal Lahiri) via Swiss Ephemeris -----
      let swe = null;

      function setStatus(ok, text) {
        statusDot.classList.toggle("good", ok);
        statusDot.classList.toggle("bad", !ok);
        statusDot.style.background = ok ? "var(--good)" : "var(--bad)";
        statusText.textContent = text;
      }

      async function initSwe() {
        try {
          swe = new SwissEph();
          await swe.initSwissEph();

          // Set Lahiri sidereal mode for Vedic usage
          // This constant exists on the wrapper.
          swe.set_sid_mode(swe.SE_SIDM_LAHIRI, 0, 0);

          setStatus(true, "Swiss Ephemeris ready");
        } catch (e) {
          console.error(e);
          setStatus(false, "Swiss Ephemeris failed to load");
        }
      }

      function degToSign(deg) {
        const signs = ["Aries","Taurus","Gemini","Cancer","Leo","Virgo","Libra","Scorpio","Sagittarius","Capricorn","Aquarius","Pisces"];
        let d = deg % 360;
        if (d < 0) d += 360;
        const signIndex = Math.floor(d / 30);
        const within = d - signIndex * 30;
        const dd = Math.floor(within);
        const mm = Math.floor((within - dd) * 60);
        return `${signs[signIndex]} ${String(dd).padStart(2,"0")}°${String(mm).padStart(2,"0")}'`;
      }

      function parseWhenLocal() {
        // datetime-local gives local time; Date(value) interprets as local and stores UTC internally.
        const v = whenEl.value;
        if (!v) return new Date();
        const dt = new Date(v);
        if (Number.isNaN(dt.getTime())) return new Date();
        return dt;
      }

      function dreamspellFromWhen(dt) {
        // Use local calendar date fields (America/Detroit assumed by user's device time zone).
        const y = dt.getFullYear();
        const m = dt.getMonth() + 1;
        const d = dt.getDate();

        const kin = dreamspellKinForDate(y, m, d);
        const moon = thirteenMoonDate(y, m, d);

        return { y, m, d, kin, moon };
      }

      function buildPromptText(seed, streamsMode, dsSummary, vedicSummary) {
        const streams = streamsMode === "A-tarot_B-iching"
          ? ["Stream A for Tarot", "Stream B for I Ching"]
          : ["Stream A for I Ching", "Stream B for Tarot"];

        const safeSeed = seed && seed.trim().length ? seed.trim() : "(blank)";

        return [
          `Seed: ${safeSeed}`,
          `Use deterministic PRNG`,
          streams[0],
          streams[1],
          ``,
          `Dreamspell (calculated): ${dsSummary}`,
          `Vedic sidereal transits (calculated): ${vedicSummary}`,
          ``,
          `Deliver a full divination report for today.`,
          `Tarot should not directly map numbers to I Ching lines.`,
        ].join("\n");
      }

      function clearVedicUI() {
        vedicList.innerHTML = "";
        vedicLine.textContent = "—";
      }

      function clearDreamspellUI() {
        dreamspellLine.textContent = "—";
        moonLine.textContent = "—";
      }

      function updateDreamspellUI(info) {
        if (info.kin.kind === "hunabku") {
          dreamspellLine.textContent = "0.0 Hunab Ku (Leap Day, no Kin)";
        } else {
          const { kin, tone, seal } = info.kin;
          dreamspellLine.textContent = `Kin ${kin} · ${TONES[tone]} ${SEALS[seal]}`;
        }

        if (info.moon.kind === "hunabku") {
          moonLine.textContent = "0.0 Hunab Ku (Leap Day adjustment day)";
        } else if (info.moon.kind === "doot") {
          moonLine.textContent = "Day Out of Time (July 25)";
        } else if (info.moon.kind === "moon") {
          moonLine.textContent = `${info.moon.moonName} Moon ${info.moon.moon} · Day ${info.moon.dayOfMoon} · ${info.moon.weekday}`;
        } else {
          moonLine.textContent = "—";
        }
      }

      function updateVedicUI(dt) {
        clearVedicUI();
        if (!swe) return;

        // Convert UTC date parts for julday
        const y = dt.getUTCFullYear();
        const m = dt.getUTCMonth() + 1;
        const d = dt.getUTCDate();
        const hour = dt.getUTCHours() + dt.getUTCMinutes() / 60 + dt.getUTCSeconds() / 3600;

        const jd = swe.julday(y, m, d, hour);

        // Flags: Swiss ephemeris + sidereal
        const flags = swe.SEFLG_SWIEPH | swe.SEFLG_SIDEREAL;

        const bodies = [
          { name: "Sun", id: swe.SE_SUN },
          { name: "Moon", id: swe.SE_MOON },
          { name: "Mercury", id: swe.SE_MERCURY },
          { name: "Venus", id: swe.SE_VENUS },
          { name: "Mars", id: swe.SE_MARS },
          { name: "Jupiter", id: swe.SE_JUPITER },
          { name: "Saturn", id: swe.SE_SATURN },
          { name: "Rahu (True Node)", id: swe.SE_TRUE_NODE },
          { name: "Ketu (Opposite)", id: "KETU" },
        ];

        // Ayanamsa value, shown for transparency
        const ay = swe.get_ayanamsa(jd);

        vedicLine.textContent = `Sidereal (Lahiri) · Ayanamsa: ${ay.toFixed(6)}°`;

        const items = [];
        for (const b of bodies) {
          if (b.id === "KETU") {
            // Ketu is opposite Rahu
            const rahu = swe.calc_ut(jd, swe.SE_TRUE_NODE, flags);
            const ketuLon = swe.degnorm(rahu[0] + 180);
            items.push({ name: b.name, lon: ketuLon });
          } else {
            const pos = swe.calc_ut(jd, b.id, flags);
            items.push({ name: b.name, lon: pos[0] });
          }
        }

        vedicList.innerHTML = items
          .map((it) => `<li><span class="mono">${it.name}</span>: <span class="mono">${degToSign(it.lon)}</span></li>`)
          .join("");
      }

      async function copyToClipboard(text) {
        try {
          await navigator.clipboard.writeText(text);
          copyStateEl.textContent = "Copied to clipboard.";
          copyStateEl.style.color = "var(--good)";
        } catch (e) {
          // Fallback
          const ta = document.createElement("textarea");
          ta.value = text;
          document.body.appendChild(ta);
          ta.select();
          try {
            document.execCommand("copy");
            copyStateEl.textContent = "Copied to clipboard.";
            copyStateEl.style.color = "var(--good)";
          } catch {
            copyStateEl.textContent = "Copy failed. Your browser blocked clipboard access.";
            copyStateEl.style.color = "var(--bad)";
          } finally {
            document.body.removeChild(ta);
          }
        }
      }

      function refreshAll() {
        const dt = parseWhenLocal();
        const ds = dreamspellFromWhen(dt);
        updateDreamspellUI(ds);
        updateVedicUI(dt);
      }

      whenEl.addEventListener("change", refreshAll);
      whenEl.addEventListener("input", refreshAll);

      buildBtn.addEventListener("click", () => {
        const dt = parseWhenLocal();
        const ds = dreamspellFromWhen(dt);

        const dsSummary = (ds.kin.kind === "hunabku")
          ? "0.0 Hunab Ku (Leap Day, no Kin)"
          : `Kin ${ds.kin.kin} (${TONES[ds.kin.tone]} ${SEALS[ds.kin.seal]})`;

        const vedicSummary = swe
          ? "Sidereal (Lahiri) positions listed below"
          : "Swiss Ephemeris not loaded";

        const txt = buildPromptText(seedEl.value, streamsEl.value, dsSummary, vedicSummary);
        promptEl.value = txt;
        copyStateEl.textContent = "";
      });

      copyBtn.addEventListener("click", async () => {
        if (!promptEl.value.trim()) {
          copyStateEl.textContent = "Nothing to copy yet. Click Build Prompt first.";
          copyStateEl.style.color = "var(--warn)";
          return;
        }
        await copyToClipboard(promptEl.value);
      });

      // Boot
      await initSwe();
      refreshAll();
    </script>
  </body>
</html>
