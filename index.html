<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Seeded RNG Divination</title>

  <!-- DEPLOY TEST: updated on 2026-01-20 -->

  <style>
    /* Forced night mode */
    :root {
      color-scheme: dark;
      --bg: #0b0f14;
      --card: #101826;
      --text: #e7edf6;
      --muted: rgba(231, 237, 246, 0.72);
      --border: rgba(231, 237, 246, 0.18);
      --border-strong: rgba(231, 237, 246, 0.28);
      --chip: rgba(231, 237, 246, 0.08);
      --btn: rgba(231, 237, 246, 0.06);
      --btn-hover: rgba(231, 237, 246, 0.10);
      --focus: rgba(120, 170, 255, 0.35);
      --good: rgba(126, 231, 135, 0.9);
      --warn: rgba(242, 204, 96, 0.9);
      --bad: rgba(255, 123, 114, 0.9);
    }

    body {
      background: var(--bg);
      color: var(--text);
      font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
      margin: 0;
      padding: 24px;
    }

    .wrap { max-width: 1100px; margin: 0 auto; display: grid; gap: 16px; }

    .card {
      background: var(--card);
      border: 1px solid var(--border);
      border-radius: 16px;
      padding: 16px;
    }

    .row { display: grid; grid-template-columns: 1fr auto; gap: 12px; align-items: end; }
    .rowBtns { display: flex; gap: 10px; justify-content: flex-end; flex-wrap: wrap; }

    label { font-size: 13px; font-weight: 600; }

    input {
      width: 100%;
      max-width: 520px;
      padding: 10px 12px;
      border-radius: 12px;
      border: 1px solid var(--border-strong);
      background: rgba(0,0,0,0.15);
      color: var(--text);
      font-size: 14px;
      outline: none;
    }

    input:focus {
      box-shadow: 0 0 0 4px var(--focus);
      border-color: rgba(120, 170, 255, 0.55);
    }

    button {
      padding: 10px 12px;
      border-radius: 12px;
      border: 1px solid var(--border-strong);
      background: var(--btn);
      color: var(--text);
      cursor: pointer;
      white-space: nowrap;
    }

    button:hover { background: var(--btn-hover); }

    .muted { opacity: .92; color: var(--muted); font-size: 12px; }
    .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace; }

    .grid2 { display: grid; grid-template-columns: 1fr; gap: 16px; }
    @media (min-width: 980px) { .grid2 { grid-template-columns: 1fr 1fr; } }

    .pill {
      display: inline-block;
      padding: 4px 8px;
      border-radius: 10px;
      border: 1px solid var(--border);
      background: var(--chip);
      margin-right: 6px;
      margin-top: 6px;
    }

    pre { white-space: pre-wrap; word-break: break-word; margin: 0; }

    .list { display: grid; gap: 10px; }
    .item {
      border: 1px solid var(--border);
      background: rgba(0,0,0,0.10);
      border-radius: 14px;
      padding: 12px;
    }

    .topline { display: flex; justify-content: space-between; gap: 12px; }
    .status { font-size: 12px; color: var(--muted); }

    .kv {
      display: grid;
      grid-template-columns: 170px 1fr;
      gap: 8px 12px;
      align-items: baseline;
      margin-top: 10px;
    }
    .kv > div:nth-child(odd) { color: var(--muted); font-size: 12px; }
    .kv > div:nth-child(even) { color: var(--text); font-size: 13px; }

    .badge {
      display: inline-flex;
      align-items: center;
      gap: 8px;
      padding: 6px 10px;
      border-radius: 999px;
      border: 1px solid var(--border);
      background: rgba(0,0,0,0.12);
      font-size: 12px;
      color: var(--muted);
      margin-left: 10px;
    }
    .dot { width: 8px; height: 8px; border-radius: 999px; background: var(--warn); }

    ul.vedic { margin: 10px 0 0; padding-left: 18px; color: var(--text); font-size: 13px; line-height: 1.45; }
    .warnbox {
      border: 1px solid rgba(242, 204, 96, 0.35);
      background: rgba(242, 204, 96, 0.06);
      border-radius: 12px;
      padding: 10px 12px;
      margin-top: 12px;
      color: var(--muted);
      font-size: 12px;
      line-height: 1.35;
    }
  </style>
</head>

<body>
  <div class="wrap">
    <div class="card">
      <div style="display:flex; align-items:flex-start; justify-content:space-between; gap:12px; flex-wrap:wrap;">
        <div>
          <h2 style="margin:0 0 6px 0;">Seeded RNG Divination</h2>
          <div class="muted">
            One seed, deterministic PRNG, two independent streams:
            <span class="mono">seed|ICHING</span> and <span class="mono">seed|TAROT</span>.
          </div>
        </div>
        <div class="badge" title="Swiss Ephemeris status">
          <span class="dot" id="sweDot"></span>
          <span id="sweStatus">Loading ephemeris…</span>
        </div>
      </div>

      <div style="height:12px;"></div>

      <div class="row">
        <div>
          <label for="seed">Seed (leave blank for noise)</label>
          <input
            id="seed"
            value=""
            maxlength="64"
            size="40"
            placeholder="(blank = Generate creates noise)"
          />
          <div class="muted" style="margin-top:6px;">
            Max 64 characters. Same seed yields the same reading. If blank, Generate creates a random seed using browser entropy.
          </div>

          <div style="height:10px;"></div>

          <label for="when">Date/Time (local, used for Dreamspell + Vedic)</label>
          <input id="when" type="datetime-local" />
          <div class="muted" style="margin-top:6px;">
            Best-guess default is “current moment.” If you prefer noon or midnight calculations, tell me and I’ll lock it.
          </div>
        </div>

        <div class="rowBtns">
          <button id="clear">Clear seed</button>
          <button id="gen">Generate</button>
        </div>
      </div>

      <div style="height:12px;"></div>

      <div><span style="font-weight:600;">Committed seed:</span> <span class="mono" id="seedOut">(none yet)</span></div>

      <div class="kv">
        <div>Dreamspell</div>
        <div class="mono" id="dreamspellLine">—</div>

        <div>13 Moon date</div>
        <div class="mono" id="moonLine">—</div>

        <div>Vedic sidereal</div>
        <div class="mono" id="vedicLine">—</div>
      </div>

      <ul class="vedic" id="vedicList"></ul>

      <div class="warnbox">
        Vedic transits here use Swiss Ephemeris WASM (Lahiri sidereal). The wrapper is GPL-licensed. Keep the repo open-source if you publish on GitHub Pages.
      </div>

      <div style="height:12px;"></div>

      <div class="muted">Declarative protocol example:</div>
      <div class="card" style="border-radius:14px; padding:12px; margin-top:8px; background: rgba(0,0,0,0.12);">
        <pre class="mono" id="proto">(generate to fill)</pre>
        <div style="height:10px;"></div>
        <div style="display:flex; gap:10px; flex-wrap:wrap; align-items:center;">
          <button id="copyProto">Copy seed protocol</button>
          <button id="copyAll">Copy full prompt + results</button>
          <span class="status" id="status"></span>
        </div>
      </div>
    </div>

    <div class="grid2">
      <div class="card">
        <h3 style="margin:0 0 6px 0;">I Ching (Stream A)</h3>
        <div class="muted">Six dice-style rolls (1–6), bottom line first. Odd=yang, even=yin. Moving if 1 or 6.</div>

        <div style="height:12px;"></div>

        <div style="font-weight:600;">Rolls (bottom → top)</div>
        <div id="rolls"></div>

        <div style="height:12px;"></div>

        <div style="font-weight:600;">Primary Hexagram (lines top → bottom)</div>
        <div class="card" style="border-radius:14px; padding:12px; margin-top:8px; background: rgba(0,0,0,0.12);">
          <div class="mono" id="lines"></div>
        </div>

        <div style="height:12px;"></div>

        <div class="grid2">
          <div class="item">
            <div style="font-weight:600;">Primary bits (top→bottom)</div>
            <div class="mono" style="font-size:18px;" id="pbits"></div>
            <div class="muted" id="ptri"></div>
          </div>
          <div class="item">
            <div style="font-weight:600;">Resulting bits (top→bottom)</div>
            <div class="mono" style="font-size:18px;" id="rbits"></div>
            <div class="muted" id="rtri"></div>
          </div>
        </div>

        <div style="height:10px;"></div>
        <div class="muted">Note: This page does not label King Wen hexagram numbers/names unless you add a verified 64-hex mapping table.</div>
      </div>

      <div class="card">
        <h3 style="margin:0 0 6px 0;">Tarot (Stream B)</h3>
        <div class="muted">Seeded shuffle of a 78-card deck, full Celtic Cross (10 cards) with seeded reversals.</div>
        <div style="height:12px;"></div>
        <div class="list" id="tarot"></div>
      </div>
    </div>
  </div>

  <script type="module">
    // =========================
    // Swiss Ephemeris (WASM)
    // =========================
    // CDN import based on swisseph-wasm project layout.
    // If this import ever 404s, tell me the console error and I’ll pin a working version or alternate CDN.
    import SwissEph from "https://cdn.jsdelivr.net/gh/prolaxu/swisseph-wasm@main/src/swisseph.js";

    const sweDot = document.getElementById("sweDot");
    const sweStatus = document.getElementById("sweStatus");
    function setSweStatus(kind, text) {
      sweStatus.textContent = text;
      sweDot.style.background = kind === "good" ? "var(--good)" : kind === "bad" ? "var(--bad)" : "var(--warn)";
    }

    let swe = null;
    async function initSwe() {
      try {
        swe = new SwissEph();
        await swe.initSwissEph();
        // Lahiri sidereal
        swe.set_sid_mode(swe.SE_SIDM_LAHIRI, 0, 0);
        setSweStatus("good", "Ephemeris ready");
      } catch (e) {
        console.error(e);
        swe = null;
        setSweStatus("bad", "Ephemeris failed");
      }
    }

    // =========================
    // PRNG: cyrb128 + sfc32
    // =========================
    function cyrb128(str) {
      let h1 = 1779033703, h2 = 3144134277, h3 = 1013904242, h4 = 2773480762;
      for (let i = 0; i < str.length; i++) {
        const k = str.charCodeAt(i);
        h1 = h2 ^ Math.imul(h1 ^ k, 597399067);
        h2 = h3 ^ Math.imul(h2 ^ k, 2869860233);
        h3 = h4 ^ Math.imul(h3 ^ k, 951274213);
        h4 = h1 ^ Math.imul(h4 ^ k, 2716044179);
      }
      h1 = Math.imul(h3 ^ (h1 >>> 18), 597399067);
      h2 = Math.imul(h4 ^ (h2 >>> 22), 2869860233);
      h3 = Math.imul(h1 ^ (h3 >>> 17), 951274213);
      h4 = Math.imul(h2 ^ (h4 >>> 19), 2716044179);
      return [(h1 ^ h2 ^ h3 ^ h4) >>> 0, (h2 ^ h1) >>> 0, (h3 ^ h1) >>> 0, (h4 ^ h1) >>> 0];
    }

    function sfc32(a,b,c,d) {
      return function() {
        a >>>= 0; b >>>= 0; c >>>= 0; d >>>= 0;
        let t = (a + b) | 0;
        a = b ^ (b >>> 9);
        b = (c + (c << 3)) | 0;
        c = (c << 21) | (c >>> 11);
        d = (d + 1) | 0;
        t = (t + d) | 0;
        c = (c + t) | 0;
        return (t >>> 0) / 4294967296;
      };
    }

    function makeRng(seedStr, salt) {
      const parts = cyrb128(seedStr + "|" + salt);
      return sfc32(parts[0], parts[1], parts[2], parts[3]);
    }

    function randIntInclusive(rng, min, max) {
      const r = rng();
      return Math.floor(r * (max - min + 1)) + min;
    }

    function normalizeSeed(raw) {
      const s = String(raw ?? "").trim();
      return s.length ? s : "0";
    }

    // Noise seed
    function generateNoiseSeed(length = 32) {
      const chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";
      const arr = new Uint32Array(length);
      crypto.getRandomValues(arr);
      let out = "";
      for (let i = 0; i < length; i++) out += chars[arr[i] % chars.length];
      return out;
    }

    // =========================
    // I Ching
    // =========================
    const TRIGRAMS = [
      { bits: "111", name: "Qian", meaning: "Heaven", symbol: "☰" },
      { bits: "000", name: "Kun", meaning: "Earth", symbol: "☷" },
      { bits: "001", name: "Zhen", meaning: "Thunder", symbol: "☳" },
      { bits: "010", name: "Kan", meaning: "Water", symbol: "☵" },
      { bits: "011", name: "Gen", meaning: "Mountain", symbol: "☶" },
      { bits: "100", name: "Xun", meaning: "Wind", symbol: "☴" },
      { bits: "101", name: "Li", meaning: "Fire", symbol: "☲" },
      { bits: "110", name: "Dui", meaning: "Lake", symbol: "☱" }
    ];

    function trigramFromBits(bitsBottomToTop3) {
      const key = bitsBottomToTop3.join("");
      return TRIGRAMS.find(t => t.bits === key) || { bits: key, name: "Unknown", meaning: "", symbol: "" };
    }

    function bitsTopToBottom(bitsBottomToTop) {
      return [...bitsBottomToTop].reverse().join("");
    }

    function lineGlyph(isYang, isMoving) {
      const base = isYang ? "━━━━━" : "━━━ ━━━";
      if (!isMoving) return base;
      return isYang ? (base + "  ○") : (base + "  ×");
    }

    function generateIching(seedStr) {
      const rng = makeRng(seedStr, "ICHING");
      const rolls = Array.from({length: 6}, () => randIntInclusive(rng, 1, 6)); // bottom->top
      const lines = rolls.map(n => ({ n, isYang: (n % 2 === 1), isMoving: (n === 1 || n === 6) }));
      const primaryBits = lines.map(ln => ln.isYang ? 1 : 0);
      const resultingBits = lines.map(ln => {
        const bit = ln.isYang ? 1 : 0;
        if (!ln.isMoving) return bit;
        return bit === 1 ? 0 : 1;
      });
      return { rolls, lines, primaryBits, resultingBits };
    }

    // =========================
    // Tarot
    // =========================
    const MAJORS = [
      "The Fool","The Magician","The High Priestess","The Empress","The Emperor","The Hierophant",
      "The Lovers","The Chariot","Strength","The Hermit","Wheel of Fortune","Justice","The Hanged Man",
      "Death","Temperance","The Devil","The Tower","The Star","The Moon","The Sun","Judgement","The World"
    ];
    const SUITS = ["Wands","Cups","Swords","Pentacles"];
    const RANKS = ["Ace","2","3","4","5","6","7","8","9","10","Page","Knight","Queen","King"];

    function buildDeck78() {
      const deck = [];
      for (let i=0;i<MAJORS.length;i++) deck.push({ id: "M"+i, label: MAJORS[i], arcana: "Major" });
      for (const suit of SUITS) {
        for (const rank of RANKS) {
          deck.push({ id: suit[0]+"-"+rank, label: rank+" of "+suit, arcana: "Minor", suit, rank });
        }
      }
      return deck;
    }

    function seededShuffle(arr, rng) {
      const a = [...arr];
      for (let i=a.length-1;i>0;i--) {
        const j = Math.floor(rng() * (i + 1));
        [a[i], a[j]] = [a[j], a[i]];
      }
      return a;
    }

    const CELTIC_CROSS = [
      "Present Condition","Crossing / Challenge","Root / Unconscious","Recent Past","Conscious Aim",
      "Near Future","Self-Position","Environment","Hopes / Fears","Integrating Outcome"
    ];

    function generateTarot(seedStr) {
      const rng = makeRng(seedStr, "TAROT");
      const deck = buildDeck78();
      const shuffled = seededShuffle(deck, rng);
      const drawn = shuffled.slice(0,10).map(card => ({ ...card, reversed: (rng() < 0.5) }));
      return { drawn };
    }

    // =========================
    // Dreamspell + 13 Moon (Argüelles)
    // =========================
    // Anchor: July 26, 1987 = Kin 34 (White Galactic Wizard)
    const DREAMSPELL_ANCHOR = { y: 1987, m: 7, d: 26, kin: 34 };

    const TONES = [
      null,
      "Magnetic","Lunar","Electric","Self-Existing","Overtone","Rhythmic","Resonant",
      "Galactic","Solar","Planetary","Spectral","Crystal","Cosmic"
    ];
    const SEALS = [
      null,
      "Red Dragon","White Wind","Blue Night","Yellow Seed","Red Serpent",
      "White Worldbridger","Blue Hand","Yellow Star","Red Moon","White Dog",
      "Blue Monkey","Yellow Human","Red Skywalker","White Wizard","Blue Eagle",
      "Yellow Warrior","Red Earth","White Mirror","Blue Storm","Yellow Sun"
    ];

    const MOON_NAMES = [
      null,
      "Magnetic","Lunar","Electric","Self-Existing","Overtone","Rhythmic","Resonant",
      "Galactic","Solar","Planetary","Spectral","Crystal","Cosmic"
    ];
    const WEEKDAY_NAMES = ["Dali","Seli","Gamma","Kali","Alpha","Limi","Silio"];

    function isLeapYearGregorian(y) {
      return (y % 4 === 0 && y % 100 !== 0) || (y % 400 === 0);
    }
    function isHunabKu(y, m, d) { return m === 2 && d === 29; }

    function utcDaysBetween(y1, m1, d1, y2, m2, d2) {
      const t1 = Date.UTC(y1, m1 - 1, d1);
      const t2 = Date.UTC(y2, m2 - 1, d2);
      return Math.round((t2 - t1) / 86400000);
    }

    function countFeb29BetweenExclusive(startY, startM, startD, endY, endM, endD) {
      const forward = Date.UTC(endY, endM - 1, endD) >= Date.UTC(startY, startM - 1, startD);
      let aY = startY, aM = startM, aD = startD;
      let bY = endY, bM = endM, bD = endD;
      if (!forward) { aY = endY; aM = endM; aD = endD; bY = startY; bM = startM; bD = startD; }

      let count = 0;
      for (let y = aY; y <= bY; y++) {
        if (!isLeapYearGregorian(y)) continue;
        const t = Date.UTC(y, 1, 29);
        const tStart = Date.UTC(aY, aM - 1, aD);
        const tEnd = Date.UTC(bY, bM - 1, bD);
        if (t > tStart && t <= tEnd) count++;
      }
      return forward ? count : -count;
    }

    function dreamspellKinForDate(y, m, d) {
      if (isHunabKu(y, m, d)) return { kind: "hunabku" };

      const rawDiff = utcDaysBetween(DREAMSPELL_ANCHOR.y, DREAMSPELL_ANCHOR.m, DREAMSPELL_ANCHOR.d, y, m, d);
      const feb29Adjust = countFeb29BetweenExclusive(DREAMSPELL_ANCHOR.y, DREAMSPELL_ANCHOR.m, DREAMSPELL_ANCHOR.d, y, m, d);
      const adjustedDiff = rawDiff - feb29Adjust;

      let kin = ((DREAMSPELL_ANCHOR.kin - 1 + adjustedDiff) % 260);
      if (kin < 0) kin += 260;
      kin += 1;

      const tone = ((kin - 1) % 13) + 1;
      const seal = ((kin - 1) % 20) + 1;

      return { kind: "kin", kin, tone, seal };
    }

    function thirteenMoonDate(y, m, d) {
      if (isHunabKu(y, m, d)) return { kind: "hunabku" };

      const tDate = Date.UTC(y, m - 1, d);
      const tStartThis = Date.UTC(y, 6, 26); // July 26
      let yearStartY = tDate < tStartThis ? y - 1 : y;

      const yearStart = { y: yearStartY, m: 7, d: 26 };
      const dayIndexRaw = utcDaysBetween(yearStart.y, yearStart.m, yearStart.d, y, m, d);
      const hunabAdjust = countFeb29BetweenExclusive(yearStart.y, yearStart.m, yearStart.d, y, m, d);
      const dayIndex = dayIndexRaw - hunabAdjust;

      const DOOT_INDEX = 364; // July 25
      if (dayIndex === DOOT_INDEX) return { kind: "doot", label: "Day Out of Time" };
      if (dayIndex < 0 || dayIndex > DOOT_INDEX) return { kind: "unknown" };

      const moon = Math.floor(dayIndex / 28) + 1;
      const dayOfMoon = (dayIndex % 28) + 1;
      const weekday = WEEKDAY_NAMES[dayIndex % 7];

      return { kind: "moon", moon, dayOfMoon, weekday, moonName: MOON_NAMES[moon] };
    }

    function parseWhenLocal() {
      const whenEl = document.getElementById("when");
      const v = whenEl.value;
      if (!v) return new Date();
      const dt = new Date(v); // interpreted as local
      if (Number.isNaN(dt.getTime())) return new Date();
      return dt;
    }

    function updateDreamspellUI(dt) {
      const y = dt.getFullYear();
      const m = dt.getMonth() + 1;
      const d = dt.getDate();

      const kin = dreamspellKinForDate(y, m, d);
      const moon = thirteenMoonDate(y, m, d);

      const dreamEl = document.getElementById("dreamspellLine");
      const moonEl = document.getElementById("moonLine");

      if (kin.kind === "hunabku") {
        dreamEl.textContent = "0.0 Hunab Ku (Leap Day, no Kin)";
      } else {
        dreamEl.textContent = `Kin ${kin.kin} · ${TONES[kin.tone]} ${SEALS[kin.seal]}`;
      }

      if (moon.kind === "hunabku") {
        moonEl.textContent = "0.0 Hunab Ku (Leap Day adjustment day)";
      } else if (moon.kind === "doot") {
        moonEl.textContent = "Day Out of Time (July 25)";
      } else if (moon.kind === "moon") {
        moonEl.textContent = `${moon.moonName} Moon ${moon.moon} · Day ${moon.dayOfMoon} · ${moon.weekday}`;
      } else {
        moonEl.textContent = "—";
      }
    }

    function degToSign(deg) {
      const signs = ["Aries","Taurus","Gemini","Cancer","Leo","Virgo","Libra","Scorpio","Sagittarius","Capricorn","Aquarius","Pisces"];
      let d = deg % 360;
      if (d < 0) d += 360;
      const signIndex = Math.floor(d / 30);
      const within = d - signIndex * 30;
      const dd = Math.floor(within);
      const mm = Math.floor((within - dd) * 60);
      return `${signs[signIndex]} ${String(dd).padStart(2,"0")}°${String(mm).padStart(2,"0")}'`;
    }

    function updateVedicUI(dt) {
      const vedicLine = document.getElementById("vedicLine");
      const vedicList = document.getElementById("vedicList");
      vedicList.innerHTML = "";

      if (!swe) {
        vedicLine.textContent = "— (ephemeris not loaded)";
        return;
      }

      const y = dt.getUTCFullYear();
      const m = dt.getUTCMonth() + 1;
      const d = dt.getUTCDate();
      const hour = dt.getUTCHours() + dt.getUTCMinutes() / 60 + dt.getUTCSeconds() / 3600;

      const jd = swe.julday(y, m, d, hour);
      const flags = swe.SEFLG_SWIEPH | swe.SEFLG_SIDEREAL;

      const ay = swe.get_ayanamsa(jd);
      vedicLine.textContent = `Sidereal (Lahiri) · Ayanamsa: ${ay.toFixed(6)}°`;

      const bodies = [
        { name: "Sun", id: swe.SE_SUN },
        { name: "Moon", id: swe.SE_MOON },
        { name: "Mercury", id: swe.SE_MERCURY },
        { name: "Venus", id: swe.SE_VENUS },
        { name: "Mars", id: swe.SE_MARS },
        { name: "Jupiter", id: swe.SE_JUPITER },
        { name: "Saturn", id: swe.SE_SATURN },
        { name: "Rahu (True Node)", id: swe.SE_TRUE_NODE },
        { name: "Ketu (Opposite)", id: "KETU" },
      ];

      const items = [];
      let rahuLon = null;

      for (const b of bodies) {
        if (b.id === "KETU") continue;
        const pos = swe.calc_ut(jd, b.id, flags);
        if (b.id === swe.SE_TRUE_NODE) rahuLon = pos[0];
        items.push({ name: b.name, lon: pos[0] });
      }

      if (rahuLon != null) {
        const ketuLon = swe.degnorm(rahuLon + 180);
        items.push({ name: "Ketu (Opposite)", lon: ketuLon });
      }

      vedicList.innerHTML = items
        .map(it => `<li><span class="mono">${it.name}</span>: <span class="mono">${degToSign(it.lon)}</span></li>`)
        .join("");
    }

    // =========================
    // Copy helpers
    // =========================
    function seedProtocolText(seedStr) {
      return "Seed: " + seedStr + "\nUse deterministic PRNG\nStream A for I Ching\nStream B for Tarot";
    }

    function buildFullPromptPlusResults(out) {
      const ich = out.ich;
      const linesTopToBottom = [...ich.lines].reverse();

      const lineText = linesTopToBottom.map((ln, idx) => {
        const lineNo = 6 - idx;
        const kind = ln.isYang ? "yang" : "yin";
        const mv = ln.isMoving ? "moving" : "static";
        return "Line " + lineNo + ": " + ln.n + " (" + kind + ", " + mv + ")";
      }).join("\n");

      const tarotText = out.tar.drawn.map((c, i) => {
        return (i+1) + ". " + CELTIC_CROSS[i] + ": " + c.label + (c.reversed ? " (Reversed)" : "");
      }).join("\n");

      const dt = parseWhenLocal();
      const y = dt.getFullYear();
      const m = dt.getMonth() + 1;
      const d = dt.getDate();
      const kin = dreamspellKinForDate(y, m, d);
      const moon = thirteenMoonDate(y, m, d);

      const dreamLine = (kin.kind === "hunabku")
        ? "0.0 Hunab Ku (Leap Day, no Kin)"
        : `Kin ${kin.kin} · ${TONES[kin.tone]} ${SEALS[kin.seal]}`;

      const moonLine = (moon.kind === "hunabku")
        ? "0.0 Hunab Ku"
        : (moon.kind === "doot")
          ? "Day Out of Time (July 25)"
          : (moon.kind === "moon")
            ? `${moon.moonName} Moon ${moon.moon} · Day ${moon.dayOfMoon} · ${moon.weekday}`
            : "—";

      const vedicHeader = document.getElementById("vedicLine").textContent || "—";
      const vedicItems = Array.from(document.querySelectorAll("#vedicList li")).map(li => li.textContent);

      return [
        seedProtocolText(out.seedStr),
        "",
        `DATE/TIME (local): ${dt.toString()}`,
        `DREAMSPELL: ${dreamLine}`,
        `13 MOON: ${moonLine}`,
        `VEDIC: ${vedicHeader}`,
        ...(vedicItems.length ? ["Vedic positions:", ...vedicItems.map(x => " - " + x)] : []),
        "",
        "I CHING (dice-style rolls bottom→top):",
        "Rolls: " + ich.rolls.join(" "),
        "Lines (top→bottom):",
        lineText,
        "",
        "TAROT (Celtic Cross):",
        tarotText
      ].join("\n");
    }

    async function copyToClipboard(text) {
      try {
        await navigator.clipboard.writeText(text);
        return true;
      } catch {
        try {
          const ta = document.createElement("textarea");
          ta.value = text;
          ta.style.position = "fixed";
          ta.style.left = "-9999px";
          document.body.appendChild(ta);
          ta.select();
          document.execCommand("copy");
          document.body.removeChild(ta);
          return true;
        } catch {
          return false;
        }
      }
    }

    // =========================
    // Render
    // =========================
    function render(out) {
      document.getElementById("seedOut").textContent = out.seedStr;
      document.getElementById("proto").textContent = seedProtocolText(out.seedStr);

      const rollsEl = document.getElementById("rolls");
      rollsEl.innerHTML = "";
      out.ich.rolls.forEach(r => {
        const s = document.createElement("span");
        s.className = "pill mono";
        s.textContent = String(r);
        rollsEl.appendChild(s);
      });

      const linesEl = document.getElementById("lines");
      linesEl.innerHTML = "";
      [...out.ich.lines].reverse().forEach(ln => {
        const div = document.createElement("div");
        div.style.display = "flex";
        div.style.justifyContent = "space-between";
        div.style.gap = "12px";

        const left = document.createElement("span");
        left.textContent = lineGlyph(ln.isYang, ln.isMoving);

        const right = document.createElement("span");
        right.className = "muted";
        right.textContent = ln.isMoving ? "moving" : "static";

        div.appendChild(left);
        div.appendChild(right);
        linesEl.appendChild(div);
      });

      document.getElementById("pbits").textContent = out.primary.bits;
      document.getElementById("rbits").textContent = out.resulting.bits;

      document.getElementById("ptri").innerHTML =
        "Upper trigram: " + out.primary.upper.symbol + " " + out.primary.upper.name + " (" + out.primary.upper.meaning + ")" +
        "<br/>Lower trigram: " + out.primary.lower.symbol + " " + out.primary.lower.name + " (" + out.primary.lower.meaning + ")";

      document.getElementById("rtri").innerHTML =
        "Upper trigram: " + out.resulting.upper.symbol + " " + out.resulting.upper.name + " (" + out.resulting.upper.meaning + ")" +
        "<br/>Lower trigram: " + out.resulting.lower.symbol + " " + out.resulting.lower.name + " (" + out.resulting.lower.meaning + ")";

      const tarotEl = document.getElementById("tarot");
      tarotEl.innerHTML = "";
      out.tar.drawn.forEach((card, i) => {
        const item = document.createElement("div");
        item.className = "item";

        const top = document.createElement("div");
        top.className = "topline";

        const left = document.createElement("div");
        const title = document.createElement("div");
        title.style.fontWeight = "600";
        title.textContent = (i+1) + ". " + CELTIC_CROSS[i];

        const label = document.createElement("div");
        label.textContent = card.label + (card.reversed ? " (Reversed)" : "");

        left.appendChild(title);
        left.appendChild(label);

        const right = document.createElement("div");
        right.className = "muted";
        right.style.textAlign = "right";
        right.textContent = card.arcana + (card.suit ? " · " + card.suit : "");

        top.appendChild(left);
        top.appendChild(right);
        item.appendChild(top);
        tarotEl.appendChild(item);
      });
    }

    function clearUI() {
      document.getElementById("seedOut").textContent = "(none yet)";
      document.getElementById("proto").textContent = "(generate to fill)";
      document.getElementById("rolls").innerHTML = "";
      document.getElementById("lines").innerHTML = "";
      document.getElementById("pbits").textContent = "";
      document.getElementById("rbits").textContent = "";
      document.getElementById("ptri").innerHTML = "";
      document.getElementById("rtri").innerHTML = "";
      document.getElementById("tarot").innerHTML = "";

      document.getElementById("dreamspellLine").textContent = "—";
      document.getElementById("moonLine").textContent = "—";
      document.getElementById("vedicLine").textContent = "—";
      document.getElementById("vedicList").innerHTML = "";
    }

    function compute(seedStr) {
      const ich = generateIching(seedStr);
      const tar = generateTarot(seedStr);

      const primaryLower = trigramFromBits(ich.primaryBits.slice(0,3));
      const primaryUpper = trigramFromBits(ich.primaryBits.slice(3,6));
      const resultingLower = trigramFromBits(ich.resultingBits.slice(0,3));
      const resultingUpper = trigramFromBits(ich.resultingBits.slice(3,6));

      return {
        seedStr,
        ich,
        tar,
        primary: { bits: bitsTopToBottom(ich.primaryBits), lower: primaryLower, upper: primaryUpper },
        resulting: { bits: bitsTopToBottom(ich.resultingBits), lower: resultingLower, upper: resultingUpper }
      };
    }

    // =========================
    // Wire up UI
    // =========================
    const seedInput = document.getElementById("seed");
    const statusEl = document.getElementById("status");
    const whenInput = document.getElementById("when");
    let currentOut = null;

    function pad2(n) { return String(n).padStart(2, "0"); }
    function setNowLocal() {
      const d = new Date();
      const v = `${d.getFullYear()}-${pad2(d.getMonth()+1)}-${pad2(d.getDate())}T${pad2(d.getHours())}:${pad2(d.getMinutes())}`;
      whenInput.value = v;
    }

    function refreshCalendars() {
      const dt = parseWhenLocal();
      updateDreamspellUI(dt);
      updateVedicUI(dt);
    }

    document.getElementById("gen").addEventListener("click", () => {
      let seedStr = seedInput.value.trim();

      if (!seedStr) {
        seedStr = generateNoiseSeed(32);
        seedInput.value = seedStr;
      }

      seedStr = normalizeSeed(seedStr);
      currentOut = compute(seedStr);
      render(currentOut);

      refreshCalendars();

      statusEl.textContent = "";
    });

    document.getElementById("clear").addEventListener("click", () => {
      seedInput.value = "";
      currentOut = null;
      statusEl.textContent = "";
      clearUI();
    });

    document.getElementById("copyProto").addEventListener("click", async () => {
      if (!currentOut) {
        statusEl.textContent = "Generate first.";
        setTimeout(() => statusEl.textContent = "", 2000);
        return;
      }
      const ok = await copyToClipboard(seedProtocolText(currentOut.seedStr));
      statusEl.textContent = ok ? "Copied seed protocol." : "Copy failed (clipboard blocked).";
      setTimeout(() => statusEl.textContent = "", ok ? 2000 : 3500);
    });

    document.getElementById("copyAll").addEventListener("click", async () => {
      if (!currentOut) {
        statusEl.textContent = "Generate first.";
        setTimeout(() => statusEl.textContent = "", 2000);
        return;
      }
      refreshCalendars();
      const ok = await copyToClipboard(buildFullPromptPlusResults(currentOut));
      statusEl.textContent = ok ? "Copied full prompt + results." : "Copy failed (clipboard blocked).";
      setTimeout(() => statusEl.textContent = "", ok ? 2000 : 3500);
    });

    whenInput.addEventListener("change", () => {
      refreshCalendars();
    });
    whenInput.addEventListener("input", () => {
      refreshCalendars();
    });

    // Boot
    setNowLocal();
    clearUI();
    await initSwe();
    refreshCalendars();
  </script>
</body>
</html>
